__text_start:
__start:
    0039 E5CF      LDI	R28,0x5F
    003A E0D4      LDI	R29,4
    003B BFCD      OUT	0x3D,R28
    003C BFDE      OUT	0x3E,R29
    003D 51C0      SUBI	R28,0x10
    003E 40D0      SBCI	R29,0
    003F EA0A      LDI	R16,0xAA
    0040 8308      STD	Y+0,R16
    0041 2400      CLR	R0
    0042 E7ED      LDI	R30,0x7D
    0043 E0F0      LDI	R31,0
    0044 E010      LDI	R17,0
    0045 38E3      CPI	R30,0x83
    0046 07F1      CPC	R31,R17
    0047 F011      BEQ	0x004A
    0048 9201      ST	R0,Z+
    0049 CFFB      RJMP	0x0045
    004A 8300      STD	Z+0,R16
    004B E5E4      LDI	R30,0x54
    004C E0F0      LDI	R31,0
    004D E6A0      LDI	R26,0x60
    004E E0B0      LDI	R27,0
    004F E010      LDI	R17,0
    0050 37E1      CPI	R30,0x71
    0051 07F1      CPC	R31,R17
    0052 F021      BEQ	0x0057
    0053 95C8      LPM
    0054 9631      ADIW	R30,1
    0055 920D      ST	R0,X+
    0056 CFF9      RJMP	0x0050
    0057 940E03C0  CALL	_main
_exit:
    0059 CFFF      RJMP	_exit
_speaData:
  y                    --> Y+4
  j                    --> Y+0
  i                    --> R10
  len                  --> R12
  dat                  --> Y+16
    005A 940E03D4  CALL	push_arg4
    005C 940E0488  CALL	push_gset4
    005E 9728      SBIW	R28,0x8
    005F 88CC      LDD	R12,Y+20
FILE: D:\ICC_H\Software.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的软件提取库，增加各类补丁，方便系统程序移植
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                       
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Software_H
(0041) #define Software_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) 
(0046) /* 兼容一般程序员的常用写法 */
(0047) typedef unsigned char	uchar;
(0048) typedef unsigned int	uint;
(0049) typedef unsigned long	ulong;
(0050) typedef signed char		schar;
(0051) typedef signed int		sint;
(0052) typedef signed long		slong;
(0053) 
(0054) /* 为方便移植，建议使用下面写法 */
(0055) typedef unsigned char	bool;
(0056) typedef unsigned char	uint8;
(0057) typedef unsigned int	uint16;
(0058) typedef unsigned long   uint32;
(0059) typedef signed  char	sint8;
(0060) typedef signed	int		sint16;
(0061) typedef signed	long	sint32;
(0062) typedef signed  char	int8;
(0063) typedef signed  int		int16;
(0064) typedef signed  long	int32;
(0065) 
(0066) /* 下面写法一般不推荐 */
(0067) //typedef unsigned char ubyte;
(0068) //typedef unsigned int	uword;
(0069) //typedef unsigned long udword;
(0070) //typedef signed   char	sbyte;
(0071) //typedef signed   int	sword;
(0072) //typedef signed   long	sdword;
(0073) 
(0074) /* 一般程序定义的默认值 */
(0075) //#define NULL			0
(0076) //#define EOF			-1
(0077) //#define TRUE   		1
(0078) //#define FALSE  		0
(0079) //#define YES   		1
(0080) //#define NO  			0
(0081) //#define ON			1
(0082) //#define OFF			0
(0083) //#define ENABLE   		1
(0084) //#define DISABLE		0
(0085) //#define CRR			1
(0086) //#define ERR			0
(0087) //#define RIGHT			1
(0088) //#define WRONG			0
(0089) //#define SUCCESS		1
(0090) //#define FAILURE		0
(0091) //#define PI			3.1415926	//3.1415926535897932
(0092) 
(0093) /* 如果你手头上的RAM实在很紧，不如尝试下面的define～ */
(0094) //#define _CALLOC(a)		( (a *)calloc(n,sizeof(a)) )
(0095) //#define _MALLOC(a)		( (a *)malloc(sizeof(a)) )
(0096) //#define _MIN(a,b)			( (a) < (b) ? (a) : (b) )
(0097) //#define _MAX(a,b)			( (a) > (b) ? (a) : (b) )
(0098) //#define _EXCHANGE(a,b)	{ int t; t=a; a=b; b=t; }
(0099) //#define _TOLOWER(c)		( (c)+32 )
(0100) //#define _TOUPPER(c)		( (c)-32 )
(0101) 
(0102) //#ifndef BIT
(0103) //#define BIT(x)	( 1<<(x) )
(0104) //#endif
(0105) 
(0106) /*--------------------------------------------------------------------
(0107) 函数全称：数据拆字
(0108) 函数功能：
(0109) 注意事项：D<=999999,C<=6
(0110) 提示说明：调用speaData(12,2)，得到dataElem[0]=2，dataElem[1]=1
(0111) 输    入：
(0112) 返    回：无
(0113) --------------------------------------------------------------------*/
(0114) uint8 dataElem[6];
(0115) void speaData(uint32 dat,sint8 len)
(0116) {
(0117)     uint8 i;
(0118)     uint32 j,y;
(0119)     for(i=0,j=1;i<len;i++)
    0060 24AA      CLR	R10
    0061 E041      LDI	R20,1
    0062 E050      LDI	R21,0
    0063 E060      LDI	R22,0
    0064 E070      LDI	R23,0
    0065 01FE      MOVW	R30,R28
    0066 8340      STD	Z+0,R20
    0067 8351      STD	Z+1,R21
    0068 8362      STD	Z+2,R22
    0069 8373      STD	Z+3,R23
    006A C046      RJMP	0x00B1
(0120)     {
(0121)         y=dat/j;
    006B 01FE      MOVW	R30,R28
    006C 8020      LDD	R2,Z+0
    006D 8031      LDD	R3,Z+1
    006E 8042      LDD	R4,Z+2
    006F 8053      LDD	R5,Z+3
    0070 01FE      MOVW	R30,R28
    0071 8860      LDD	R6,Z+16
    0072 8871      LDD	R7,Z+17
    0073 8882      LDD	R8,Z+18
    0074 8893      LDD	R9,Z+19
    0075 925A      ST	R5,-Y
    0076 924A      ST	R4,-Y
    0077 923A      ST	R3,-Y
    0078 922A      ST	R2,-Y
    0079 0183      MOVW	R16,R6
    007A 0194      MOVW	R18,R8
    007B 940E03D9  CALL	div32u
    007D 01FE      MOVW	R30,R28
    007E 8304      STD	Z+4,R16
    007F 8315      STD	Z+5,R17
    0080 8326      STD	Z+6,R18
    0081 8337      STD	Z+7,R19
(0122)         dataElem[i]=y%10;
    0082 E04A      LDI	R20,0xA
    0083 E050      LDI	R21,0
    0084 E060      LDI	R22,0
    0085 E070      LDI	R23,0
    0086 01FE      MOVW	R30,R28
    0087 8024      LDD	R2,Z+4
    0088 8035      LDD	R3,Z+5
    0089 8046      LDD	R4,Z+6
    008A 8057      LDD	R5,Z+7
    008B 937A      ST	R23,-Y
    008C 936A      ST	R22,-Y
    008D 935A      ST	R21,-Y
    008E 934A      ST	R20,-Y
    008F 0181      MOVW	R16,R2
    0090 0192      MOVW	R18,R4
    0091 940E03DB  CALL	mod32u
    0093 E78D      LDI	R24,0x7D
    0094 E090      LDI	R25,0
    0095 2DEA      MOV	R30,R10
    0096 27FF      CLR	R31
    0097 0FE8      ADD	R30,R24
    0098 1FF9      ADC	R31,R25
    0099 8300      STD	Z+0,R16
(0123)         j*=10;
    009A 01FE      MOVW	R30,R28
    009B 8020      LDD	R2,Z+0
    009C 8031      LDD	R3,Z+1
    009D 8042      LDD	R4,Z+2
    009E 8053      LDD	R5,Z+3
    009F E04A      LDI	R20,0xA
    00A0 E050      LDI	R21,0
    00A1 E060      LDI	R22,0
    00A2 E070      LDI	R23,0
    00A3 925A      ST	R5,-Y
    00A4 924A      ST	R4,-Y
    00A5 923A      ST	R3,-Y
    00A6 922A      ST	R2,-Y
    00A7 018A      MOVW	R16,R20
    00A8 019B      MOVW	R18,R22
    00A9 940E044A  CALL	empy32u
    00AB 01FE      MOVW	R30,R28
    00AC 8300      STD	Z+0,R16
    00AD 8311      STD	Z+1,R17
    00AE 8322      STD	Z+2,R18
    00AF 8333      STD	Z+3,R19
    00B0 94A3      INC	R10
    00B1 14AC      CP	R10,R12
    00B2 F408      BCC	0x00B4
    00B3 CFB7      RJMP	0x006B
    00B4 9628      ADIW	R28,0x8
    00B5 940E0480  CALL	pop_gset4
    00B7 9624      ADIW	R28,4
    00B8 9508      RET
FILE: D:\ICC_H\I2C.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立I2C操作库
(0005) 	
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033) 
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036) 
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef I2C_H
(0041) #define I2C_H
(0042) 
(0043) #include "D:\ICC_H\CmmICC.H"
(0044) 
(0045) /* TWSR values (not bits) */
(0046) /* Master */
(0047) #define I2C_START			0x08
(0048) #define I2C_RESTART			0x10
(0049) 
(0050) /* Master Transmitter */
(0051) #define I2C_MT_SLA_ACK		0x18
(0052) #define I2C_MT_SLA_NACK		0x20
(0053) #define I2C_MT_DATA_ACK		0x28
(0054) #define I2C_MT_DATA_NACK	0x30
(0055) #define I2C_MT_ARB_LOST		0x38
(0056) 
(0057) /* Master Receiver */
(0058) #define I2C_MR_ARB_LOST		0x38
(0059) #define I2C_MR_SLA_ACK		0x40
(0060) #define I2C_MR_SLA_NACK		0x48
(0061) #define I2C_MR_DATA_ACK		0x50
(0062) #define I2C_MR_DATA_NACK	0x58
(0063) 
(0064) /* Slave Transmitter */
(0065) #define I2C_ST_SLA_ACK			0xA8
(0066) #define I2C_ST_ARB_LOST_SLA_ACK 0xB0
(0067) #define I2C_ST_DATA_ACK			0xB8
(0068) #define I2C_ST_DATA_NACK		0xC0
(0069) #define I2C_ST_LAST_DATA		0xC8
(0070) 
(0071) /* Slave Receiver */
(0072) #define I2C_SR_SLA_ACK				0x60
(0073) #define I2C_SR_ARB_LOST_SLA_ACK		0x68
(0074) #define I2C_SR_GCALL_ACK			0x70
(0075) #define I2C_SR_ARB_LOST_GCALL_ACK	0x78
(0076) #define I2C_SR_DATA_ACK				0x80
(0077) #define I2C_SR_DATA_NACK			0x88
(0078) #define I2C_SR_GCALL_DATA_ACK		0x90
(0079) #define I2C_SR_GCALL_DATA_NACK		0x98
(0080) #define I2C_SR_STOP					0xA0
(0081) 
(0082) /* Misc */
(0083) #define I2C_NO_INFO			0xF8
(0084) #define I2C_BUS_ERROR		0x00
(0085) 
(0086) /*
(0087)  * The lower 3 bits of TWSR are reserved on the ATmega163.
(0088)  * The 2 LSB carry the prescaler bits on the newer ATmegas.
(0089)  */
(0090) #define I2C_STATUS_MASK	(_BV(TWS7)|_BV(TWS6)|_BV(TWS5)|_BV(TWS4)|_BV(TWS3))
(0091) #define I2C_STATUS		(TWSR & I2C_STATUS_MASK)
(0092) 
(0093) /*
(0094)  * R/~W bit in SLA+R/W address field.
(0095)  */
(0096) #define I2C_READ		1
(0097) #define I2C_WRITE		0
(0098) 
(0099) #define I2CStart()    	(TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN))
(0100) #define I2CStop()     	(TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN))
(0101) #define I2CWaitAck()	{while(!(TWCR&(1<<TWINT)));}
(0102) #define I2CChkAck() 	(TWSR&0xf8)					//check ack
(0103) #define I2CSendAck()	(TWCR|=(1<<TWEA))
(0104) #define I2CSendNoAck()	(TWCR&=~(1<<TWEA))
(0105) #define I2CSendByte(x)	{TWDR=(x);TWCR=(1<<TWINT)|(1<<TWEN);} 
(0106) #define I2CRcvNckByte()	(TWCR=(1<<TWINT)|(1<<TWEN))
(0107) #define I2CRcvAckByte()	(TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA))
(0108) 
(0109) /* For Program */
(0110) #define I2C_Stop()		I2CStop()
(0111) #define I2C_SendAck()	I2CSendAck()
(0112) #define I2C_SendNoAck() I2CSendNoAck()
(0113) #define I2C_WaitAck()	I2CWaitAck()
(0114) 
(0115) /* I2C Config */
(0116) #define I2C_ERR			0
(0117) #define I2C_CRR			1
(0118) 
(0119) /*--------------------------------------------------------------------
(0120) 函数名称：I2C Start
(0121) 函数功能：
(0122) 注意事项：
(0123) 提示说明：
(0124) 输    入：
(0125) 返    回：
(0126) --------------------------------------------------------------------*/
(0127) bool I2C_Start()					
(0128) {
(0129) 	I2CStart();						
_I2C_Start:
    00B9 EA84      LDI	R24,0xA4
    00BA BF86      OUT	0x36,R24
(0130) 	I2CWaitAck();
    00BB B626      IN	R2,0x36
    00BC FE27      SBRS	R2,7
    00BD CFFD      RJMP	0x00BB
(0131) 	if( I2CChkAck()!=I2C_START ) 
    00BE B181      IN	R24,0x01
    00BF 7F88      ANDI	R24,0xF8
    00C0 3088      CPI	R24,0x8
    00C1 F011      BEQ	0x00C4
(0132) 		return I2C_ERR;
    00C2 2700      CLR	R16
    00C3 C001      RJMP	0x00C5
(0133) 	return I2C_CRR;
    00C4 E001      LDI	R16,1
    00C5 9508      RET
(0134) }
(0135) /*--------------------------------------------------------------------
(0136) 函数名称：I2C ReStart
(0137) 函数功能：
(0138) 注意事项：
(0139) 提示说明：
(0140) 输    入：
(0141) 返    回：
(0142) --------------------------------------------------------------------*/
(0143) bool I2C_Restart()					
(0144) {
(0145) 	I2CStart();						
_I2C_Restart:
    00C6 EA84      LDI	R24,0xA4
    00C7 BF86      OUT	0x36,R24
(0146) 	I2CWaitAck();
    00C8 B626      IN	R2,0x36
    00C9 FE27      SBRS	R2,7
    00CA CFFD      RJMP	0x00C8
(0147) 	if( I2CChkAck()!=I2C_RESTART ) 
    00CB B181      IN	R24,0x01
    00CC 7F88      ANDI	R24,0xF8
    00CD 3180      CPI	R24,0x10
    00CE F011      BEQ	0x00D1
(0148) 		return I2C_ERR;
    00CF 2700      CLR	R16
    00D0 C001      RJMP	0x00D2
(0149) 	return I2C_CRR;
    00D1 E001      LDI	R16,1
    00D2 9508      RET
(0150) }
(0151) /*--------------------------------------------------------------------
(0152) 函数名称：发送 7位 器件写地址: XXXX XXX0
(0153) 函数功能：
(0154) 注意事项：
(0155) 提示说明：
(0156) 输    入：
(0157) 返    回：
(0158) --------------------------------------------------------------------*/
(0159) bool I2C_SendWrDAdr(uint8 wrDAdr)	
(0160) {
(0161) 	I2CSendByte(wrDAdr);			//设置 器件写地址
_I2C_SendWrDAdr:
  wrDAdr               --> R16
    00D3 B903      OUT	0x03,R16
    00D4 E884      LDI	R24,0x84
    00D5 BF86      OUT	0x36,R24
(0162) 	I2CWaitAck();
    00D6 B626      IN	R2,0x36
    00D7 FE27      SBRS	R2,7
    00D8 CFFD      RJMP	0x00D6
(0163) 	if( I2CChkAck()!=I2C_MT_SLA_ACK )  
    00D9 B181      IN	R24,0x01
    00DA 7F88      ANDI	R24,0xF8
    00DB 3188      CPI	R24,0x18
    00DC F011      BEQ	0x00DF
(0164) 		return I2C_ERR;
    00DD 2700      CLR	R16
    00DE C001      RJMP	0x00E0
(0165) 	return I2C_CRR;		
    00DF E001      LDI	R16,1
    00E0 9508      RET
_I2C_SendWrDAdr_:
  wrDAdr               --> R20
    00E1 940E048E  CALL	push_gset1
    00E3 01A8      MOVW	R20,R16
(0166) }
(0167) /*--------------------------------------------------------------------
(0168) 函数名称：发送 10位 器件写地址: 1111 0XX0, XXXX XXXX
(0169) 函数功能：
(0170) 注意事项：
(0171) 提示说明：兼容 发送 7位 器件写地址: XXXX XXX0
(0172) 输    入：
(0173) 返    回：
(0174) --------------------------------------------------------------------*/
(0175) bool I2C_SendWrDAdr_(uint16 wrDAdr)	
(0176) {
(0177) 	if( wrDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    00E4 FF40      SBRS	R20,0
    00E5 C00B      RJMP	0x00F1
(0178) 		if( I2C_SendWrDAdr( (uint8)wrDAdr>>8 )==I2C_ERR )	//设置 （高位）器件写地址
    00E6 2F04      MOV	R16,R20
    00E7 2711      CLR	R17
    00E8 2F01      MOV	R16,R17
    00E9 2711      CLR	R17
    00EA FD07      SBRC	R16,7
    00EB 9510      COM	R17
    00EC DFE6      RCALL	_I2C_SendWrDAdr
    00ED 2300      TST	R16
    00EE F411      BNE	0x00F1
(0179) 			return I2C_ERR;
    00EF 2700      CLR	R16
    00F0 C007      RJMP	0x00F8
(0180) 	if( I2C_SendWrDAdr( (uint8)wrDAdr )==I2C_ERR )	//设置 （低位）器件写地址
    00F1 2F04      MOV	R16,R20
    00F2 DFE0      RCALL	_I2C_SendWrDAdr
    00F3 2300      TST	R16
    00F4 F411      BNE	0x00F7
(0181) 		return I2C_ERR;
    00F5 2700      CLR	R16
    00F6 C001      RJMP	0x00F8
(0182) 	return I2C_CRR;
    00F7 E001      LDI	R16,1
    00F8 940E0491  CALL	pop_gset1
    00FA 9508      RET
(0183) }
(0184) /*--------------------------------------------------------------------
(0185) 函数名称：发送 7位 器件读地址: XXXX XXX1
(0186) 函数功能：
(0187) 注意事项：
(0188) 提示说明：
(0189) 输    入：
(0190) 返    回：
(0191) --------------------------------------------------------------------*/
(0192) bool I2C_SendRdDAdr(uint8 rdDAdr)	
(0193) {
(0194) 	I2CSendByte(rdDAdr);			//设置 器件读地址
_I2C_SendRdDAdr:
  rdDAdr               --> R16
    00FB B903      OUT	0x03,R16
    00FC E884      LDI	R24,0x84
    00FD BF86      OUT	0x36,R24
(0195) 	I2CWaitAck();
    00FE B626      IN	R2,0x36
    00FF FE27      SBRS	R2,7
    0100 CFFD      RJMP	0x00FE
(0196) 	if( I2CChkAck()!=I2C_MR_SLA_ACK )  
    0101 B181      IN	R24,0x01
    0102 7F88      ANDI	R24,0xF8
    0103 3480      CPI	R24,0x40
    0104 F011      BEQ	0x0107
(0197) 		return I2C_ERR;
    0105 2700      CLR	R16
    0106 C001      RJMP	0x0108
(0198) 	return I2C_CRR;	
    0107 E001      LDI	R16,1
    0108 9508      RET
_I2C_SendRdDAdr_:
  rdDAdr               --> R20
    0109 940E048E  CALL	push_gset1
    010B 2F40      MOV	R20,R16
(0199) }
(0200) /*--------------------------------------------------------------------
(0201) 函数名称：发送 10位 器件读地址: 1111 0XX0, XXXX XXXX
(0202) 函数功能：
(0203) 注意事项：
(0204) 提示说明：
(0205) 输    入：
(0206) 返    回：
(0207) --------------------------------------------------------------------*/
(0208) bool I2C_SendRdDAdr_(uint8 rdDAdr)	
(0209) {
(0210) 	if( rdDAdr&0xF000 == 0xF000 )	//判断是否为 10位 器件地址
    010C FF40      SBRS	R20,0
    010D C00B      RJMP	0x0119
(0211) 		if( I2C_SendWrDAdr( (uint8)rdDAdr>>8 )==I2C_ERR )	//设置 （高位）器件读地址
    010E 2F04      MOV	R16,R20
    010F 2711      CLR	R17
    0110 2F01      MOV	R16,R17
    0111 2711      CLR	R17
    0112 FD07      SBRC	R16,7
    0113 9510      COM	R17
    0114 DFBE      RCALL	_I2C_SendWrDAdr
    0115 2300      TST	R16
    0116 F411      BNE	0x0119
(0212) 			return I2C_ERR;
    0117 2700      CLR	R16
    0118 C007      RJMP	0x0120
(0213) 	if( I2C_SendWrDAdr( (uint8)rdDAdr )==I2C_ERR )	//设置 （低位）器件读地址
    0119 2F04      MOV	R16,R20
    011A DFB8      RCALL	_I2C_SendWrDAdr
    011B 2300      TST	R16
    011C F411      BNE	0x011F
(0214) 		return I2C_ERR;
    011D 2700      CLR	R16
    011E C001      RJMP	0x0120
(0215) 	return I2C_CRR;
    011F E001      LDI	R16,1
    0120 940E0491  CALL	pop_gset1
    0122 9508      RET
(0216) }
(0217) /*--------------------------------------------------------------------
(0218) 函数名称：I2C发送数据
(0219) 函数功能：
(0220) 注意事项：
(0221) 提示说明：
(0222) 输    入：
(0223) 返    回：
(0224) --------------------------------------------------------------------*/
(0225) bool I2C_SendDat(uint8 configDat)	
(0226) {
(0227) 	I2CSendByte(configDat);			
_I2C_SendDat:
  configDat            --> R16
    0123 B903      OUT	0x03,R16
    0124 E884      LDI	R24,0x84
    0125 BF86      OUT	0x36,R24
(0228) 	I2CWaitAck();
    0126 B626      IN	R2,0x36
    0127 FE27      SBRS	R2,7
    0128 CFFD      RJMP	0x0126
(0229) 	if( I2CChkAck()!=I2C_MT_DATA_ACK ) 
    0129 B181      IN	R24,0x01
    012A 7F88      ANDI	R24,0xF8
    012B 3288      CPI	R24,0x28
    012C F011      BEQ	0x012F
(0230) 		return I2C_ERR;
    012D 2700      CLR	R16
    012E C001      RJMP	0x0130
(0231) 	return I2C_CRR;	
    012F E001      LDI	R16,1
    0130 9508      RET
(0232) }
(0233) /*--------------------------------------------------------------------
(0234) 函数名称：I2C接收数据且不产生应答
(0235) 函数功能：
(0236) 注意事项：
(0237) 提示说明：
(0238) 输    入：
(0239) 返    回：
(0240) --------------------------------------------------------------------*/
(0241) bool I2C_RcvNAckDat(uint8 *pRdDat)	
(0242) {
(0243) 	I2CRcvNckByte();
_I2C_RcvNAckDat:
  pRdDat               --> R16
    0131 E884      LDI	R24,0x84
    0132 BF86      OUT	0x36,R24
(0244) 	I2CWaitAck();
    0133 B626      IN	R2,0x36
    0134 FE27      SBRS	R2,7
    0135 CFFD      RJMP	0x0133
(0245) 	if( I2CChkAck()!=I2C_MR_DATA_NACK )
    0136 B181      IN	R24,0x01
    0137 7F88      ANDI	R24,0xF8
    0138 3588      CPI	R24,0x58
    0139 F011      BEQ	0x013C
(0246) 		return I2C_ERR;
    013A 2700      CLR	R16
    013B C004      RJMP	0x0140
(0247) 	*pRdDat=TWDR;
    013C B023      IN	R2,0x03
    013D 01F8      MOVW	R30,R16
    013E 8220      STD	Z+0,R2
(0248) 	return I2C_CRR;
    013F E001      LDI	R16,1
    0140 9508      RET
(0249) }
(0250) /*--------------------------------------------------------------------
(0251) 函数名称：I2C接收数据且产生应答
(0252) 函数功能：
(0253) 注意事项：
(0254) 提示说明：
(0255) 输    入：
(0256) 返    回：
(0257) --------------------------------------------------------------------*/
(0258) bool I2C_RcvAckDat(uint8 *pRdDat)	
(0259) {
(0260) 	I2CRcvAckByte();					
_I2C_RcvAckDat:
  pRdDat               --> R16
    0141 EC84      LDI	R24,0xC4
    0142 BF86      OUT	0x36,R24
(0261) 	I2CWaitAck();
    0143 B626      IN	R2,0x36
    0144 FE27      SBRS	R2,7
    0145 CFFD      RJMP	0x0143
(0262) 	if( I2CChkAck()!=I2C_MR_DATA_ACK )
    0146 B181      IN	R24,0x01
    0147 7F88      ANDI	R24,0xF8
    0148 3580      CPI	R24,0x50
    0149 F011      BEQ	0x014C
(0263) 		return I2C_ERR;
    014A 2700      CLR	R16
    014B C004      RJMP	0x0150
(0264) 	*pRdDat=TWDR;
    014C B023      IN	R2,0x03
    014D 01F8      MOVW	R30,R16
    014E 8220      STD	Z+0,R2
(0265) 	return I2C_CRR;
    014F E001      LDI	R16,1
    0150 9508      RET
_I2C_Write:
  dat                  --> Y+4
  wordAdr              --> R20
  wrDAdr               --> R22
    0151 940E048C  CALL	push_gset2
    0153 2F42      MOV	R20,R18
    0154 01B8      MOVW	R22,R16
(0266) }
(0267) /*--------------------------------------------------------------------
(0268) 函数名称：I2C写器件，写一个数据
(0269) 函数功能：
(0270) 注意事项：
(0271) 提示说明：
(0272) 输    入：wrDAdr: write device-address 写器件地址
(0273) 		 wordAdr: word address 字地址
(0274) 		 dat: data 数据
(0275) 返    回：
(0276) --------------------------------------------------------------------*/
(0277) bool I2C_Write(uint16 wrDAdr,uint8 wordAdr,uint8 dat)
(0278) {
(0279) 	if( I2C_Start()==I2C_ERR )
    0155 DF63      RCALL	_I2C_Start
    0156 2300      TST	R16
    0157 F411      BNE	0x015A
(0280) 		return I2C_ERR;
    0158 2700      CLR	R16
    0159 C015      RJMP	0x016F
(0281) 
(0282) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    015A 018B      MOVW	R16,R22
    015B DF85      RCALL	_I2C_SendWrDAdr_
    015C 2300      TST	R16
    015D F411      BNE	0x0160
(0283) 		return I2C_ERR;
    015E 2700      CLR	R16
    015F C00F      RJMP	0x016F
(0284) 
(0285) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    0160 2F04      MOV	R16,R20
    0161 DFC1      RCALL	_I2C_SendDat
    0162 2300      TST	R16
    0163 F411      BNE	0x0166
(0286) 		return I2C_ERR;
    0164 2700      CLR	R16
    0165 C009      RJMP	0x016F
(0287) 
(0288) 	if( I2C_SendDat(dat)==I2C_ERR )
    0166 810C      LDD	R16,Y+4
    0167 DFBB      RCALL	_I2C_SendDat
    0168 2300      TST	R16
    0169 F411      BNE	0x016C
(0289) 		return I2C_ERR;
    016A 2700      CLR	R16
    016B C003      RJMP	0x016F
(0290) 
(0291) 	I2C_Stop();
    016C E984      LDI	R24,0x94
    016D BF86      OUT	0x36,R24
(0292) 
(0293) 	return I2C_CRR;
    016E E001      LDI	R16,1
    016F 940E047A  CALL	pop_gset2
    0171 9508      RET
_I2C_Read:
  pRdDat               --> Y+6
  rdDAdr               --> Y+4
  wordAdr              --> R20
  wrDAdr               --> R22
    0172 940E048C  CALL	push_gset2
    0174 2F42      MOV	R20,R18
    0175 01B8      MOVW	R22,R16
(0294) }
(0295) /*--------------------------------------------------------------------
(0296) 函数名称：I2C写器件，写N个数据
(0297) 函数功能：
(0298) 注意事项：
(0299) 提示说明：
(0300) 输    入：wrDAdr: write device-address 写器件地址
(0301) 		 wordAdr: word address 字地址
(0302) 		 *pWrDat: p->write data 写入数据指针
(0303) 		 num: number 写入数据个数
(0304) 返    回：
(0305) --------------------------------------------------------------------*/
(0306) //bool I2C_Write_(uint16 wrDAdr,uint8 wordAdr,
(0307) //				  uint8 *pWrDat,uint8 num)
(0308) //{
(0309) //
(0310) //} 
(0311) /*--------------------------------------------------------------------
(0312) 函数名称：I2C读器件，读一个数据
(0313) 函数功能：
(0314) 注意事项：
(0315) 提示说明：
(0316) 输    入：wrDAdr: write device-address 写器件地址
(0317) 		 wordAdr: word address 字地址
(0318) 		 rdDAdr: read device-address 读器件地址
(0319) 		 *pRdDat: p->read data 读取数据指针
(0320) 返    回：
(0321) --------------------------------------------------------------------*/
(0322) bool I2C_Read(uint16 wrDAdr,uint8 wordAdr,
(0323) 			  uint8 rdDAdr,uint8 *pRdDat)
(0324) {
(0325) 	if( I2C_Start()==I2C_ERR )
    0176 DF42      RCALL	_I2C_Start
    0177 2300      TST	R16
    0178 F411      BNE	0x017B
(0326) 		return I2C_ERR;
    0179 2700      CLR	R16
    017A C021      RJMP	0x019C
(0327) 
(0328) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    017B 018B      MOVW	R16,R22
    017C DF64      RCALL	_I2C_SendWrDAdr_
    017D 2300      TST	R16
    017E F411      BNE	0x0181
(0329) 		return I2C_ERR;
    017F 2700      CLR	R16
    0180 C01B      RJMP	0x019C
(0330) 
(0331) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    0181 2F04      MOV	R16,R20
    0182 DFA0      RCALL	_I2C_SendDat
    0183 2300      TST	R16
    0184 F411      BNE	0x0187
(0332) 		return I2C_ERR;
    0185 2700      CLR	R16
    0186 C015      RJMP	0x019C
(0333) 
(0334) 	if( I2C_Restart()==I2C_ERR )
    0187 DF3E      RCALL	_I2C_Restart
    0188 2300      TST	R16
    0189 F411      BNE	0x018C
(0335) 		return I2C_ERR;
    018A 2700      CLR	R16
    018B C010      RJMP	0x019C
(0336) 
(0337) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    018C 810C      LDD	R16,Y+4
    018D DF6D      RCALL	_I2C_SendRdDAdr
    018E 2300      TST	R16
    018F F411      BNE	0x0192
(0338) 		return I2C_ERR;
    0190 2700      CLR	R16
    0191 C00A      RJMP	0x019C
(0339) 
(0340) 	if( I2C_RcvNAckDat(pRdDat)==I2C_ERR )
    0192 810E      LDD	R16,Y+6
    0193 811F      LDD	R17,Y+7
    0194 DF9C      RCALL	_I2C_RcvNAckDat
    0195 2300      TST	R16
    0196 F411      BNE	0x0199
(0341) 		return I2C_ERR;
    0197 2700      CLR	R16
    0198 C003      RJMP	0x019C
(0342) 
(0343) 	I2C_Stop();
    0199 E984      LDI	R24,0x94
    019A BF86      OUT	0x36,R24
(0344) 
(0345) 	return I2C_CRR;
    019B E001      LDI	R16,1
    019C 940E047A  CALL	pop_gset2
    019E 9508      RET
_I2C_Read_:
  i                    --> R20
  num                  --> R22
  pRdDat               --> R10
  rdDAdr               --> Y+8
  wordAdr              --> R20
  wrDAdr               --> R12
    019F 940E0488  CALL	push_gset4
    01A1 2F42      MOV	R20,R18
    01A2 0168      MOVW	R12,R16
    01A3 84AA      LDD	R10,Y+10
    01A4 84BB      LDD	R11,Y+11
    01A5 856C      LDD	R22,Y+12
(0346) }
(0347) /*--------------------------------------------------------------------
(0348) 函数名称：I2C读器件，读N个数据
(0349) 函数功能：
(0350) 注意事项：
(0351) 提示说明：
(0352) 输    入：wrDAdr: write device-address 写器件地址
(0353) 		 wordAdr: word address 字地址
(0354) 		 rdDAdr: read device-address 读器件地址
(0355) 		 *pRdDat: p->read data 读取数据指针
(0356) 		 num: number 读取数据个数
(0357) 返    回：
(0358) --------------------------------------------------------------------*/
(0359) bool I2C_Read_(uint16 wrDAdr,uint8 wordAdr,
(0360) 			   uint8 rdDAdr,uint8 *pRdDat,uint8 num)
(0361) {
(0362)  	uint8 i;
(0363) 	
(0364) 	if( I2C_Start()==I2C_ERR )
    01A6 DF12      RCALL	_I2C_Start
    01A7 2300      TST	R16
    01A8 F411      BNE	0x01AB
(0365) 		return I2C_ERR;
    01A9 2700      CLR	R16
    01AA C033      RJMP	0x01DE
(0366) 
(0367) 	if( I2C_SendWrDAdr_(wrDAdr)==I2C_ERR )
    01AB 0186      MOVW	R16,R12
    01AC DF34      RCALL	_I2C_SendWrDAdr_
    01AD 2300      TST	R16
    01AE F411      BNE	0x01B1
(0368) 		return I2C_ERR;
    01AF 2700      CLR	R16
    01B0 C02D      RJMP	0x01DE
(0369) 
(0370) 	if( I2C_SendDat(wordAdr)==I2C_ERR )
    01B1 2F04      MOV	R16,R20
    01B2 DF70      RCALL	_I2C_SendDat
    01B3 2300      TST	R16
    01B4 F411      BNE	0x01B7
(0371) 		return I2C_ERR;
    01B5 2700      CLR	R16
    01B6 C027      RJMP	0x01DE
(0372) 
(0373) 	if( I2C_Restart()==I2C_ERR )
    01B7 DF0E      RCALL	_I2C_Restart
    01B8 2300      TST	R16
    01B9 F411      BNE	0x01BC
(0374) 		return I2C_ERR;
    01BA 2700      CLR	R16
    01BB C022      RJMP	0x01DE
(0375) 
(0376) 	if( I2C_SendRdDAdr(rdDAdr)==I2C_ERR )
    01BC 8508      LDD	R16,Y+8
    01BD DF3D      RCALL	_I2C_SendRdDAdr
    01BE 2300      TST	R16
    01BF F411      BNE	0x01C2
(0377) 		return I2C_ERR;
    01C0 2700      CLR	R16
    01C1 C01C      RJMP	0x01DE
(0378) 
(0379) 	for(i=0;i<num-1;i++)
    01C2 2744      CLR	R20
    01C3 C00A      RJMP	0x01CE
(0380) 		if( I2C_RcvAckDat(pRdDat+i)==I2C_ERR )
    01C4 2F04      MOV	R16,R20
    01C5 2711      CLR	R17
    01C6 0D0A      ADD	R16,R10
    01C7 1D1B      ADC	R17,R11
    01C8 DF78      RCALL	_I2C_RcvAckDat
    01C9 2300      TST	R16
    01CA F411      BNE	0x01CD
(0381) 			return I2C_ERR;
    01CB 2700      CLR	R16
    01CC C011      RJMP	0x01DE
    01CD 9543      INC	R20
    01CE 2F86      MOV	R24,R22
    01CF 5081      SUBI	R24,1
    01D0 1748      CP	R20,R24
    01D1 F390      BCS	0x01C4
(0382) 	
(0383) 	if( I2C_RcvNAckDat(pRdDat+i)==I2C_ERR )
    01D2 2F04      MOV	R16,R20
    01D3 2711      CLR	R17
    01D4 0D0A      ADD	R16,R10
    01D5 1D1B      ADC	R17,R11
    01D6 DF5A      RCALL	_I2C_RcvNAckDat
    01D7 2300      TST	R16
    01D8 F411      BNE	0x01DB
(0384) 			return I2C_ERR;
    01D9 2700      CLR	R16
    01DA C003      RJMP	0x01DE
(0385) 
(0386) 	I2C_Stop();
    01DB E984      LDI	R24,0x94
    01DC BF86      OUT	0x36,R24
(0387) 	
(0388) 	return I2C_CRR;
    01DD E001      LDI	R16,1
    01DE 940E0480  CALL	pop_gset4
    01E0 9508      RET
_delay50us:
  j                    --> R20
  t                    --> R16
    01E1 940E048E  CALL	push_gset1
FILE: D:\ICC_H\Hardware.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                        
(0004) 目    的:   建立AVR的硬件提取库，增加各类补丁，方便移植
(0005) 					
(0006) 目标系统:   基于AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权     
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 入口参数说明：
(0027) 
(0028) ----------------------------------------------------------------------
(0029) 待定参数说明：
(0030) 
(0031) ----------------------------------------------------------------------	
(0032) 对外变量说明：
(0033)     
(0034) ----------------------------------------------------------------------
(0035) 对外函数说明：
(0036)    
(0037) ----------------------------------------------------------------------
(0038) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0039) 
(0040) #ifndef Hardware_H
(0041) #define Hardware_H
(0042) 
(0043) #include <math.h>
(0044) #include <string.h>
(0045) #include <stdio.h>
(0046) #include <macros.h>
(0047) #include <eeprom.h>
(0048) //#include <wdt.h>
(0049) 
(0050) /* TWI configs */
(0051) //如使用ATMEGA162(没有TWI接口)之类的MCU，在加载Hardware.H前，务必加“#define NO_INCLUDE_I2C_H 1”语句
(0052) #if NO_INCLUDE_I2C_H
(0053) ;
(0054) #else
(0055) #include "D:\ICC_H\I2C.H"	//i2c即AVR的"twi"
(0056) #endif
(0057) 
(0058) /* hard configs */
(0059) #ifndef flash
(0060) 	#define flash	const
(0061) #endif
(0062) 
(0063) #ifndef code
(0064) 	#define code	const
(0065) #endif
(0066) 
(0067) #ifndef NOP
(0068) 	#define NOP()	asm("nop")
(0069) #endif
(0070) 
(0071) /* io configs */
(0072) #define sbi(io,bit)		(  io |=  (1<<bit) )	//example: sbi(PORTA,0);sbi(DDRA,0);
(0073) #define cbi(io,bit)		(  io &= ~(1<<bit) )	//example: cbi(PORTA,0);cbi(DDRA,0);
(0074) #define gbi(pin ,bit)	( pin &   (1<<bit) )	//example: gbi(PINA,0);
(0075) 
(0076) /* interrupt configs */
(0077) #define DIS_INT  asm("sei")
(0078) #define EN_INT   asm("cli")
(0079) 
(0080) /* wdt configs */
(0081) #define WDT()    asm("wdr")
(0082) 
(0083) /* bit operation */
(0084) //#ifndef BIT
(0085) //#define BIT(x)	( 1<<(x) )
(0086) //#endif
(0087) 
(0088) /* USART configs for 4 Mhz crystal */
(0089) //#define BAUD9600			25
(0090) //#define BAUD19000			12
(0091) //#define UART_TRAN_ON()	UCR |=  0x08
(0092) //#define UART_TRAN_OFF()	UCR &= ~0x08
(0093) //#define UART_RCV_ON()		UCR |=  0x10
(0094) //#define UART_RCV_OFF()	UCR &= ~0x10
(0095) 
(0096) /*--------------------------------------------------------------------
(0097) 函数全称：50us 延时
(0098) 函数功能：当然是 50us延时 啦
(0099) 注意事项：基于7.3728M晶振，稍微有点误差
(0100) 提示说明：调用delay50us（20），得到1ms延时
(0101) 输    入：	
(0102) 返    回：无 
(0103) --------------------------------------------------------------------*/
(0104) void delay50us(sint16 t)
(0105) {
(0106)     uint8 j;		
(0107)     for(;t>0;t--)			
    01E3 C007      RJMP	0x01EB
(0108)         for(j=0;j<70;j++)	
    01E4 2744      CLR	R20
    01E5 C001      RJMP	0x01E7
    01E6 9543      INC	R20
    01E7 3446      CPI	R20,0x46
    01E8 F3E8      BCS	0x01E6
    01E9 5001      SUBI	R16,1
    01EA 4010      SBCI	R17,0
    01EB 2422      CLR	R2
    01EC 2433      CLR	R3
    01ED 1620      CP	R2,R16
    01EE 0631      CPC	R3,R17
    01EF F3A4      BLT	0x01E4
    01F0 940E0491  CALL	pop_gset1
    01F2 9508      RET
_delay50ms:
  i                    --> R20
  t                    --> R16
    01F3 940E048E  CALL	push_gset1
(0109)             ;
(0110) }
(0111) /*--------------------------------------------------------------------
(0112) 函数全称：50ms 延时
(0113) 函数功能：当然是 50ms延时 啦
(0114) 注意事项：基于7.3728M晶振，稍微有点误差
(0115) 提示说明：调用delay50ms（20），得到1s延时 
(0116) 输    入：
(0117) 返    回：无
(0118) --------------------------------------------------------------------*/
(0119) void delay50ms(sint16 t)
(0120) {
(0121) 	uint16 i; 
(0122) 	for(;t>0;t--)
    01F5 C00B      RJMP	0x0201
(0123) 		for(i=0;i<52642;i++)
    01F6 2744      CLR	R20
    01F7 2755      CLR	R21
    01F8 C002      RJMP	0x01FB
    01F9 5F4F      SUBI	R20,0xFF
    01FA 4F5F      SBCI	R21,0xFF
    01FB 3A42      CPI	R20,0xA2
    01FC ECED      LDI	R30,0xCD
    01FD 075E      CPC	R21,R30
    01FE F3D0      BCS	0x01F9
    01FF 5001      SUBI	R16,1
    0200 4010      SBCI	R17,0
    0201 2422      CLR	R2
    0202 2433      CLR	R3
    0203 1620      CP	R2,R16
    0204 0631      CPC	R3,R17
    0205 F384      BLT	0x01F6
    0206 940E0491  CALL	pop_gset1
    0208 9508      RET
FILE: D:\ICC_H\LCD12864_ST7920.H
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 	                                                        
(0004) 目    的:   建立LCD12864_ST7920的串模式操作库
(0005) 
(0006) 目标系统:   基于AVR单片机
(0007) 	                                                                
(0008) 应用软件:   ICCAVR                                               
(0009) 	                                                                
(0010) 版    本:   Version 1.0
(0011) 	                                                                
(0012) 圆版时间:   2005-09-06
(0013) 
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权 
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) 
(0026) 
(0027) ----------------------------------------------------------------------
(0028) 入口参数说明：
(0029) 	//#define OUT_LCD_CS	sbi(DDRD,0)
(0030) 	//#define SET_LCD_CS	sbi(PORTD,0)
(0031) 	//#define CLR_LCD_CS	cbi(PORTD,0)
(0032) 
(0033) ----------------------------------------------------------------------
(0034) 待定参数说明：
(0035) 	
(0036) 
(0037) ----------------------------------------------------------------------	
(0038) 对外变量说明：
(0039) 
(0040) ----------------------------------------------------------------------
(0041) 对外函数说明：
(0042) 
(0043) ----------------------------------------------------------------------
(0044) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0045) 
(0046) 
(0047) /*--------------------------------------------------------------------
(0048) 接口定义：
(0049) 
(0050) LCD12864_ST7920			ATmega16
(0051) 1.GND		--------	GND
(0052) 2.VCC		--------	VCC
(0053) 3.V0		--------	V0
(0054) 4.RS(CS)	--------	VCC
(0055) 5.R/W(SID)	--------	MOSI/PB5
(0056) 6.E(SCLK)	--------	SCK/PB7
(0057) 7.D0		--------	NC
(0058) 8.D1		--------	NC
(0059) 9.D2		--------	NC
(0060) 10.D3		--------	NC
(0061) 11.D4		--------	NC
(0062) 12.D5		--------	NC
(0063) 13.D6		--------	NC
(0064) 14.D7		--------	NC
(0065) 15.PSB		--------	GND
(0066) 16.NC		--------	NC
(0067) 17.RST		--------	NC
(0068) 18.NC		--------	NC
(0069) 19.LED+		--------	VCC
(0070) 20.LED-		--------	GND
(0071) 
(0072) 说明：
(0073) （1）使用ATmega16的硬件SPI操作LCD12864_ST7920
(0074) （2）PIN4/CS接VCC，其实也可接到特定的IO口，但外部程序需要指定
(0075) --------------------------------------------------------------------*/
(0076) 
(0077) #ifndef LCD12864_ST7920_H
(0078) #define LCD12864_ST7920_H
(0079) 
(0080) #include "D:\ICC_H\CmmIcc.h"
(0081) 
(0082) void SPI_init()
(0083) {
(0084) 	DDRB |= 0xB0;
_SPI_init:
    0209 B387      IN	R24,0x17
    020A 6B80      ORI	R24,0xB0
    020B BB87      OUT	0x17,R24
(0085) 	SPCR = 0x50;	//setup SPI
    020C E580      LDI	R24,0x50
    020D B98D      OUT	0x0D,R24
(0086) 	SPSR = 0x01;	//setup SPI
    020E E081      LDI	R24,1
    020F B98E      OUT	0x0E,R24
(0087) 	SEI();			
    0210 9478      BSET	7
    0211 9508      RET
(0088) }
(0089) 
(0090) void lcd_wrByte(uint8 data)
(0091) {  
(0092) 	SPDR = data;        
_lcd_wrByte:
  data                 --> R16
    0212 B90F      OUT	0x0F,R16
(0093) 	while ((SPSR & 0x80) == 0);  
    0213 9B77      SBIS	0x0E,7
    0214 CFFE      RJMP	0x0213
    0215 9508      RET
_lcd_wrCmd:
  LC                   --> R20
  HC                   --> R22
    0216 940E048C  CALL	push_gset2
    0218 2F42      MOV	R20,R18
    0219 2F60      MOV	R22,R16
(0094) }
(0095) 
(0096) void lcd_wrCmd(uint8 HC,uint8 LC)
(0097) {
(0098) 	lcd_wrByte(0xF8);
    021A EF08      LDI	R16,0xF8
    021B DFF6      RCALL	_lcd_wrByte
(0099) 	lcd_wrByte(HC);		//传输高四位
    021C 2F06      MOV	R16,R22
    021D DFF4      RCALL	_lcd_wrByte
(0100) 	lcd_wrByte(LC);		//传输低四位
    021E 2F04      MOV	R16,R20
    021F DFF2      RCALL	_lcd_wrByte
    0220 940E047A  CALL	pop_gset2
    0222 9508      RET
_lcd_wrDat:
  LD                   --> R20
  HD                   --> R22
    0223 940E048C  CALL	push_gset2
    0225 2F42      MOV	R20,R18
    0226 2F60      MOV	R22,R16
(0101) }
(0102) 
(0103) void lcd_wrDat(uint8 HD,uint8 LD)
(0104) {
(0105) 	lcd_wrByte(0xFA);
    0227 EF0A      LDI	R16,0xFA
    0228 DFE9      RCALL	_lcd_wrByte
(0106) 	lcd_wrByte(HD);		//传输高四位
    0229 2F06      MOV	R16,R22
    022A DFE7      RCALL	_lcd_wrByte
(0107) 	lcd_wrByte(LD);		//传输低四位
    022B 2F04      MOV	R16,R20
    022C DFE5      RCALL	_lcd_wrByte
    022D 940E047A  CALL	pop_gset2
    022F 9508      RET
_lcd_set_xy:
  adr                  --> R20
  y                    --> R22
  x                    --> R20
    0230 940E048C  CALL	push_gset2
    0232 2F62      MOV	R22,R18
    0233 2F40      MOV	R20,R16
(0108) } 
(0109) 
(0110) /*
(0111) x表示在第几行显示，y表示在第几列显示
(0112) */
(0113) void lcd_set_xy(uint8 x,uint8 y) 
(0114) {
(0115) 	uint8 adr;
(0116) 
(0117) 	switch(x)
    0234 2755      CLR	R21
    0235 3041      CPI	R20,1
    0236 E0E0      LDI	R30,0
    0237 075E      CPC	R21,R30
    0238 F069      BEQ	0x0246
    0239 3042      CPI	R20,2
    023A E0E0      LDI	R30,0
    023B 075E      CPC	R21,R30
    023C F061      BEQ	0x0249
    023D 3043      CPI	R20,3
    023E E0E0      LDI	R30,0
    023F 075E      CPC	R21,R30
    0240 F059      BEQ	0x024C
    0241 3044      CPI	R20,4
    0242 E0E0      LDI	R30,0
    0243 075E      CPC	R21,R30
    0244 F051      BEQ	0x024F
    0245 C00B      RJMP	0x0251
(0118) 	{
(0119) 	case 1: adr = 0x7F + y;
    0246 2F46      MOV	R20,R22
    0247 5841      SUBI	R20,0x81
(0120) 		break;		//在第1行y列显示
    0248 C008      RJMP	0x0251
(0121) 	case 2: adr = 0x8F + y;
    0249 2F46      MOV	R20,R22
    024A 5741      SUBI	R20,0x71
(0122) 		break;		//在第2行y列显示
    024B C005      RJMP	0x0251
(0123) 	case 3: adr = 0x87 + y;
    024C 2F46      MOV	R20,R22
    024D 5749      SUBI	R20,0x79
(0124) 		break;		//在第3行y列显示
    024E C002      RJMP	0x0251
(0125) 	case 4: adr = 0x97 + y;
    024F 2F46      MOV	R20,R22
    0250 5649      SUBI	R20,0x69
(0126) 		break;		//在第4行y列显示
(0127) 	default:	;
(0128) 	}
(0129) 	lcd_wrCmd(adr&0xF0,(adr&0x0F)<<4);
    0251 2F24      MOV	R18,R20
    0252 702F      ANDI	R18,0xF
    0253 702F      ANDI	R18,0xF
    0254 9522      SWAP	R18
    0255 2F04      MOV	R16,R20
    0256 7F00      ANDI	R16,0xF0
    0257 DFBE      RCALL	_lcd_wrCmd
    0258 940E047A  CALL	pop_gset2
    025A 9508      RET
_lcd_putc:
  ch                   --> Y+4
  y                    --> R22
  x                    --> R20
    025B 940E048C  CALL	push_gset2
    025D 2F62      MOV	R22,R18
    025E 2F40      MOV	R20,R16
(0130) }
(0131) 
(0132) void lcd_putc(uint8 x,uint8 y,uint8 ch)
(0133) {
(0134) 	lcd_set_xy(x,y);
    025F 2F26      MOV	R18,R22
    0260 2F04      MOV	R16,R20
    0261 DFCE      RCALL	_lcd_set_xy
(0135) 	delay50us(20); 
    0262 E104      LDI	R16,0x14
    0263 E010      LDI	R17,0
    0264 DF7C      RCALL	_delay50us
(0136) 	lcd_wrDat(ch&0xF0,(ch&0x0F)<<4);
    0265 812C      LDD	R18,Y+4
    0266 702F      ANDI	R18,0xF
    0267 702F      ANDI	R18,0xF
    0268 9522      SWAP	R18
    0269 810C      LDD	R16,Y+4
    026A 7F00      ANDI	R16,0xF0
    026B DFB7      RCALL	_lcd_wrDat
    026C 940E047A  CALL	pop_gset2
    026E 9508      RET
_lcd_putd0:
  i                    --> R20
  length               --> Y+9
  dat                  --> Y+5
  y                    --> R22
  x                    --> R20
    026F 940E048C  CALL	push_gset2
    0271 2F62      MOV	R22,R18
    0272 2F40      MOV	R20,R16
    0273 9721      SBIW	R28,1
(0137) }
(0138) 
(0139) void lcd_putd0(uint8 x,uint8 y,uint32 dat,uint8 length)
(0140) {
(0141) 	sint8 i;
(0142) 
(0143) 	speaData(dat,length);
    0274 8409      LDD	R0,Y+9
    0275 8208      STD	Y+0,R0
    0276 01FE      MOVW	R30,R28
    0277 8105      LDD	R16,Z+5
    0278 8116      LDD	R17,Z+6
    0279 8127      LDD	R18,Z+7
    027A 8530      LDD	R19,Z+8
    027B DDDE      RCALL	_speaData
(0144) 	lcd_set_xy(x,y);
    027C 2F26      MOV	R18,R22
    027D 2F04      MOV	R16,R20
    027E DFB1      RCALL	_lcd_set_xy
(0145) 	delay50us(40);
    027F E208      LDI	R16,0x28
    0280 E010      LDI	R17,0
    0281 DF5F      RCALL	_delay50us
(0146) 	for(i=length-1;i>=0;i--)
    0282 8549      LDD	R20,Y+9
    0283 5041      SUBI	R20,1
    0284 C01E      RJMP	0x02A3
(0147) 	{
(0148) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    0285 E78D      LDI	R24,0x7D
    0286 E090      LDI	R25,0
    0287 2FE4      MOV	R30,R20
    0288 27FF      CLR	R31
    0289 FDE7      SBRC	R30,7
    028A 95F0      COM	R31
    028B 0FE8      ADD	R30,R24
    028C 1FF9      ADC	R31,R25
    028D 8180      LDD	R24,Z+0
    028E 2799      CLR	R25
    028F 96C0      ADIW	R24,0x30
    0290 2F28      MOV	R18,R24
    0291 702F      ANDI	R18,0xF
    0292 7030      ANDI	R19,0
    0293 0F22      LSL	R18
    0294 1F33      ROL	R19
    0295 0F22      LSL	R18
    0296 1F33      ROL	R19
    0297 0F22      LSL	R18
    0298 1F33      ROL	R19
    0299 0F22      LSL	R18
    029A 1F33      ROL	R19
    029B 2F08      MOV	R16,R24
    029C 7F00      ANDI	R16,0xF0
    029D 7010      ANDI	R17,0
    029E DF84      RCALL	_lcd_wrDat
(0149) 		delay50us(40); 
    029F E208      LDI	R16,0x28
    02A0 E010      LDI	R17,0
    02A1 DF3F      RCALL	_delay50us
    02A2 954A      DEC	R20
    02A3 3040      CPI	R20,0
    02A4 F704      BGE	0x0285
    02A5 9621      ADIW	R28,1
    02A6 940E047A  CALL	pop_gset2
    02A8 9508      RET
_lcd_putd:
  effectLen            --> R12
  i                    --> R10
  length               --> Y+15
  dat                  --> Y+11
  y                    --> R14
  x                    --> R10
    02A9 940E0486  CALL	push_gset5
    02AB 2EE2      MOV	R14,R18
    02AC 2EA0      MOV	R10,R16
    02AD 9721      SBIW	R28,1
(0150) 	}
(0151) }
(0152) 
(0153) void lcd_putd(uint8 x,uint8 y,uint32 dat,uint8 length)
(0154) {
(0155) 	sint8 i;
(0156) 	sint8 effectLen;
(0157) 
(0158) 	if(dat>999999)
    02AE E34F      LDI	R20,0x3F
    02AF E452      LDI	R21,0x42
    02B0 E06F      LDI	R22,0xF
    02B1 E070      LDI	R23,0
    02B2 01FE      MOVW	R30,R28
    02B3 8423      LDD	R2,Z+11
    02B4 8434      LDD	R3,Z+12
    02B5 8445      LDD	R4,Z+13
    02B6 8456      LDD	R5,Z+14
    02B7 1542      CP	R20,R2
    02B8 0553      CPC	R21,R3
    02B9 0564      CPC	R22,R4
    02BA 0575      CPC	R23,R5
    02BB F418      BCC	0x02BF
(0159) 		effectLen=7;
    02BC E087      LDI	R24,7
    02BD 2EC8      MOV	R12,R24
    02BE C057      RJMP	0x0316
(0160) 	else if(dat>99999)
    02BF E94F      LDI	R20,0x9F
    02C0 E856      LDI	R21,0x86
    02C1 E061      LDI	R22,1
    02C2 E070      LDI	R23,0
    02C3 01FE      MOVW	R30,R28
    02C4 8423      LDD	R2,Z+11
    02C5 8434      LDD	R3,Z+12
    02C6 8445      LDD	R4,Z+13
    02C7 8456      LDD	R5,Z+14
    02C8 1542      CP	R20,R2
    02C9 0553      CPC	R21,R3
    02CA 0564      CPC	R22,R4
    02CB 0575      CPC	R23,R5
    02CC F418      BCC	0x02D0
(0161) 		effectLen=6;
    02CD E086      LDI	R24,6
    02CE 2EC8      MOV	R12,R24
    02CF C046      RJMP	0x0316
(0162) 	else if(dat>9999)
    02D0 E04F      LDI	R20,0xF
    02D1 E257      LDI	R21,0x27
    02D2 E060      LDI	R22,0
    02D3 E070      LDI	R23,0
    02D4 01FE      MOVW	R30,R28
    02D5 8423      LDD	R2,Z+11
    02D6 8434      LDD	R3,Z+12
    02D7 8445      LDD	R4,Z+13
    02D8 8456      LDD	R5,Z+14
    02D9 1542      CP	R20,R2
    02DA 0553      CPC	R21,R3
    02DB 0564      CPC	R22,R4
    02DC 0575      CPC	R23,R5
    02DD F418      BCC	0x02E1
(0163) 		effectLen=5;
    02DE E085      LDI	R24,5
    02DF 2EC8      MOV	R12,R24
    02E0 C035      RJMP	0x0316
(0164) 	else if(dat>999)
    02E1 EE47      LDI	R20,0xE7
    02E2 E053      LDI	R21,3
    02E3 E060      LDI	R22,0
    02E4 E070      LDI	R23,0
    02E5 01FE      MOVW	R30,R28
    02E6 8423      LDD	R2,Z+11
    02E7 8434      LDD	R3,Z+12
    02E8 8445      LDD	R4,Z+13
    02E9 8456      LDD	R5,Z+14
    02EA 1542      CP	R20,R2
    02EB 0553      CPC	R21,R3
    02EC 0564      CPC	R22,R4
    02ED 0575      CPC	R23,R5
    02EE F418      BCC	0x02F2
(0165) 		effectLen=4;
    02EF E084      LDI	R24,4
    02F0 2EC8      MOV	R12,R24
    02F1 C024      RJMP	0x0316
(0166) 	else if(dat>99)
    02F2 E643      LDI	R20,0x63
    02F3 E050      LDI	R21,0
    02F4 E060      LDI	R22,0
    02F5 E070      LDI	R23,0
    02F6 01FE      MOVW	R30,R28
    02F7 8423      LDD	R2,Z+11
    02F8 8434      LDD	R3,Z+12
    02F9 8445      LDD	R4,Z+13
    02FA 8456      LDD	R5,Z+14
    02FB 1542      CP	R20,R2
    02FC 0553      CPC	R21,R3
    02FD 0564      CPC	R22,R4
    02FE 0575      CPC	R23,R5
    02FF F418      BCC	0x0303
(0167) 		effectLen=3;
    0300 E083      LDI	R24,3
    0301 2EC8      MOV	R12,R24
    0302 C013      RJMP	0x0316
(0168) 	else if(dat>9)
    0303 E049      LDI	R20,0x9
    0304 E050      LDI	R21,0
    0305 E060      LDI	R22,0
    0306 E070      LDI	R23,0
    0307 01FE      MOVW	R30,R28
    0308 8423      LDD	R2,Z+11
    0309 8434      LDD	R3,Z+12
    030A 8445      LDD	R4,Z+13
    030B 8456      LDD	R5,Z+14
    030C 1542      CP	R20,R2
    030D 0553      CPC	R21,R3
    030E 0564      CPC	R22,R4
    030F 0575      CPC	R23,R5
    0310 F418      BCC	0x0314
(0169) 		effectLen=2;
    0311 E082      LDI	R24,2
    0312 2EC8      MOV	R12,R24
    0313 C002      RJMP	0x0316
(0170) 	else
(0171) 		effectLen=1;
    0314 24CC      CLR	R12
    0315 94C3      INC	R12
(0172) 	speaData(dat,effectLen);
    0316 82C8      STD	Y+0,R12
    0317 01FE      MOVW	R30,R28
    0318 8503      LDD	R16,Z+11
    0319 8514      LDD	R17,Z+12
    031A 8525      LDD	R18,Z+13
    031B 8536      LDD	R19,Z+14
    031C DD3D      RCALL	_speaData
(0173) 
(0174) 	lcd_set_xy(x,y);
    031D 2D2E      MOV	R18,R14
    031E 2D0A      MOV	R16,R10
    031F DF10      RCALL	_lcd_set_xy
(0175) 	delay50us(40); 
    0320 E208      LDI	R16,0x28
    0321 E010      LDI	R17,0
    0322 DEBE      RCALL	_delay50us
(0176) 	if(length>effectLen)
    0323 840F      LDD	R0,Y+15
    0324 14C0      CP	R12,R0
    0325 F478      BCC	0x0335
(0177) 	{
(0178) 		for(i=length-effectLen-1;i>=0;i--)
    0326 2D80      MOV	R24,R0
    0327 198C      SUB	R24,R12
    0328 5081      SUBI	R24,1
    0329 2EA8      MOV	R10,R24
    032A C007      RJMP	0x0332
(0179) 		{
(0180) 			lcd_wrDat(' '&0xF0,(' '&0x0F)<<4);
    032B 2722      CLR	R18
    032C E200      LDI	R16,0x20
    032D DEF5      RCALL	_lcd_wrDat
(0181) 			delay50us(40); 
    032E E208      LDI	R16,0x28
    032F E010      LDI	R17,0
    0330 DEB0      RCALL	_delay50us
    0331 94AA      DEC	R10
    0332 2D8A      MOV	R24,R10
    0333 3080      CPI	R24,0
    0334 F7B4      BGE	0x032B
(0182) 		}
(0183) 	}
(0184) 	for(i=effectLen-1;i>=0;i--)
    0335 2D8C      MOV	R24,R12
    0336 5081      SUBI	R24,1
    0337 2EA8      MOV	R10,R24
    0338 C01E      RJMP	0x0357
(0185) 	{
(0186) 		lcd_wrDat( (dataElem[i]+0x30)&0xF0 ,( (dataElem[i]+0x30)&0x0F )<<4 );
    0339 E78D      LDI	R24,0x7D
    033A E090      LDI	R25,0
    033B 2DEA      MOV	R30,R10
    033C 27FF      CLR	R31
    033D FDE7      SBRC	R30,7
    033E 95F0      COM	R31
    033F 0FE8      ADD	R30,R24
    0340 1FF9      ADC	R31,R25
    0341 8180      LDD	R24,Z+0
    0342 2799      CLR	R25
    0343 96C0      ADIW	R24,0x30
    0344 2F28      MOV	R18,R24
    0345 702F      ANDI	R18,0xF
    0346 7030      ANDI	R19,0
    0347 0F22      LSL	R18
    0348 1F33      ROL	R19
    0349 0F22      LSL	R18
    034A 1F33      ROL	R19
    034B 0F22      LSL	R18
    034C 1F33      ROL	R19
    034D 0F22      LSL	R18
    034E 1F33      ROL	R19
    034F 2F08      MOV	R16,R24
    0350 7F00      ANDI	R16,0xF0
    0351 7010      ANDI	R17,0
    0352 DED0      RCALL	_lcd_wrDat
(0187) 		delay50us(40);
    0353 E208      LDI	R16,0x28
    0354 E010      LDI	R17,0
    0355 DE8B      RCALL	_delay50us
    0356 94AA      DEC	R10
    0357 2D8A      MOV	R24,R10
    0358 3080      CPI	R24,0
    0359 F6FC      BGE	0x0339
    035A 9621      ADIW	R28,1
    035B 940E0483  CALL	pop_gset5
    035D 9508      RET
_lcd_puts:
  str                  --> R20
  y                    --> R10
  x                    --> R22
    035E 940E048A  CALL	push_gset3
    0360 2EA2      MOV	R10,R18
    0361 2F60      MOV	R22,R16
    0362 814E      LDD	R20,Y+6
    0363 815F      LDD	R21,Y+7
(0188) 	}
(0189) }
(0190) 
(0191) void lcd_puts(uint8 x,uint8 y,uint8 *str)
(0192) { 
(0193) 	lcd_set_xy(x,y);
    0364 2D2A      MOV	R18,R10
    0365 2F06      MOV	R16,R22
    0366 DEC9      RCALL	_lcd_set_xy
(0194) 	delay50us(20);   
    0367 E104      LDI	R16,0x14
    0368 E010      LDI	R17,0
    0369 DE77      RCALL	_delay50us
    036A C00F      RJMP	0x037A
(0195) 	while(*str)
(0196) 	{
(0197) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    036B 01FA      MOVW	R30,R20
    036C 8020      LDD	R2,Z+0
    036D 2433      CLR	R3
    036E 2D22      MOV	R18,R2
    036F 702F      ANDI	R18,0xF
    0370 702F      ANDI	R18,0xF
    0371 9522      SWAP	R18
    0372 2D02      MOV	R16,R2
    0373 7F00      ANDI	R16,0xF0
    0374 DEAE      RCALL	_lcd_wrDat
(0198) 		str++;
    0375 5F4F      SUBI	R20,0xFF
    0376 4F5F      SBCI	R21,0xFF
(0199) 		delay50us(20);
    0377 E104      LDI	R16,0x14
    0378 E010      LDI	R17,0
    0379 DE67      RCALL	_delay50us
    037A 01FA      MOVW	R30,R20
    037B 8020      LDD	R2,Z+0
    037C 2022      TST	R2
    037D F769      BNE	0x036B
    037E 940E047D  CALL	pop_gset3
    0380 9508      RET
_lcd_puts_:
  dlyMs                --> R20
  str                  --> R22
  y                    --> R12
  x                    --> R10
    0381 940E0488  CALL	push_gset4
    0383 2EC2      MOV	R12,R18
    0384 2EA0      MOV	R10,R16
    0385 8568      LDD	R22,Y+8
    0386 8579      LDD	R23,Y+9
    0387 854A      LDD	R20,Y+10
(0200) 	} 
(0201) }
(0202) 
(0203) void lcd_puts_(uint8 x,uint8 y,uint8 *str,uint8 dlyMs)
(0204) { 
(0205) 	lcd_set_xy(x,y);
    0388 2D2C      MOV	R18,R12
    0389 2D0A      MOV	R16,R10
    038A DEA5      RCALL	_lcd_set_xy
(0206) 	delay50us(20);   
    038B E104      LDI	R16,0x14
    038C E010      LDI	R17,0
    038D DE53      RCALL	_delay50us
    038E C00F      RJMP	0x039E
(0207) 	while(*str)
(0208) 	{
(0209) 		lcd_wrDat((*(str))&0xF0,((*(str))&0x0F)<<4);
    038F 01FB      MOVW	R30,R22
    0390 8020      LDD	R2,Z+0
    0391 2433      CLR	R3
    0392 2D22      MOV	R18,R2
    0393 702F      ANDI	R18,0xF
    0394 702F      ANDI	R18,0xF
    0395 9522      SWAP	R18
    0396 2D02      MOV	R16,R2
    0397 7F00      ANDI	R16,0xF0
    0398 DE8A      RCALL	_lcd_wrDat
(0210) 		str++;
    0399 5F6F      SUBI	R22,0xFF
    039A 4F7F      SBCI	R23,0xFF
(0211) 		delay50ms(dlyMs);
    039B 2F04      MOV	R16,R20
    039C 2711      CLR	R17
    039D DE55      RCALL	_delay50ms
    039E 01FB      MOVW	R30,R22
    039F 8020      LDD	R2,Z+0
    03A0 2022      TST	R2
    03A1 F769      BNE	0x038F
    03A2 940E0480  CALL	pop_gset4
    03A4 9508      RET
(0212) 	} 
(0213) }
(0214) 
(0215) void lcd_clr()
(0216) {
(0217) 	lcd_wrCmd(0x00,0x10);	//显示右移
_lcd_clr:
    03A5 E120      LDI	R18,0x10
    03A6 2700      CLR	R16
    03A7 DE6E      RCALL	_lcd_wrCmd
(0218) 	delay50us(200);
    03A8 EC08      LDI	R16,0xC8
    03A9 E010      LDI	R17,0
    03AA DE36      RCALL	_delay50us
    03AB 9508      RET
(0219) }
(0220) 
(0221) void lcd_init(void)
(0222) {
(0223) 	SPI_init();	
_lcd_init:
    03AC DE5C      RCALL	_SPI_init
(0224) 	//OUT_LCD_CS;		//若LCD_CS
(0225) 	//SET_LCD_CS;		
(0226) 	delay50ms(1);
    03AD E001      LDI	R16,1
    03AE E010      LDI	R17,0
    03AF DE43      RCALL	_delay50ms
(0227) 	lcd_wrCmd(0x30,0x30);	//使用8位控制界面,使用基本指令集
    03B0 E320      LDI	R18,0x30
    03B1 E300      LDI	R16,0x30
    03B2 DE63      RCALL	_lcd_wrCmd
(0228) 	//lcd_wrCmd(0x00,0xF0);	//整体显示ON
(0229) 	lcd_wrCmd(0x00,0xC0);	//整体显示ON
    03B3 EC20      LDI	R18,0xC0
    03B4 2700      CLR	R16
    03B5 DE60      RCALL	_lcd_wrCmd
(0230) 	lcd_wrCmd(0x00,0x10);	//清屏
    03B6 E120      LDI	R18,0x10
    03B7 2700      CLR	R16
    03B8 DE5D      RCALL	_lcd_wrCmd
(0231) 	//lcd_wrCmd(0x10,0x00);	//光标
(0232) 	lcd_wrCmd(0x00,0x60);
    03B9 E620      LDI	R18,0x60
    03BA 2700      CLR	R16
    03BB DE5A      RCALL	_lcd_wrCmd
(0233) 	//lcd_wrCmd(0x00,0x70);	//显示右移
(0234) 	delay50ms(1);		//不可省去！！！
    03BC E001      LDI	R16,1
    03BD E010      LDI	R17,0
    03BE DE34      RCALL	_delay50ms
    03BF 9508      RET
_main:
    03C0 9722      SBIW	R28,2
FILE: E:\微雪电子CD1\产品资料\开发板实验板\SMK系列\SMK1632\实验教程\外围模块相关实验\LCD128~1\LCD12864_ST7920\LCD12864_ST7920.C
(0001) /*********************************************************************
(0002) 	微 雪 电 子   WaveShare   http://www.waveShare.net            	
(0003) 		                                                            
(0004) 目    的:   建立操作LCD12864_ST7920液晶的示例程序
(0005) 
(0006) 目标系统:   基于任何AVR单片机
(0007) 		                                                                
(0008) 应用软件:   ICCAVR
(0009) 		                                                                
(0010) 版    本:   Version 1.0                                                          
(0011) 		                                                                
(0012) 圆版时间:   2005-06-25
(0013) 	
(0014) 开发人员:   SEE
(0015) 
(0016) 说    明:   若用于商业用途，请保留此段文字或注明代码来源
(0017) 	
(0018) 	深 圳 市 微 雪 电 子 有 限 公 司 保 留 所 有 的 版 权
(0019) *********************************************************************/
(0020) 
(0021) /*01010101010101010101010101010101010101010101010101010101010101010101
(0022) ----------------------------------------------------------------------
(0023) 版本更新记录：
(0024) 
(0025) ----------------------------------------------------------------------
(0026) 实验内容：
(0027) 初始化、读写Lcd12864_ST7920。
(0028) ----------------------------------------------------------------------
(0029) 硬件连接：
(0030) LCD12864_ST7920			ATmega16
(0031) 1.GND		--------	GND
(0032) 2.VCC		--------	VCC
(0033) 3.V0		--------	V0
(0034) 4.RS(CS)	--------	VCC
(0035) 5.R/W(SID)	--------	MOSI/PB5
(0036) 6.E(SCLK)	--------	SCK/PB7
(0037) 7.D0		--------	NC
(0038) 8.D1		--------	NC
(0039) 9.D2		--------	NC
(0040) 10.D3		--------	NC
(0041) 11.D4		--------	NC
(0042) 12.D5		--------	NC
(0043) 13.D6		--------	NC
(0044) 14.D7		--------	NC
(0045) 15.PSB		--------	GND
(0046) 16.NC		--------	NC
(0047) 17.RST		--------	NC
(0048) 18.NC		--------	NC
(0049) 19.LED+		--------	VCC
(0050) 20.LED-		--------	GND
(0051) 
(0052) 操作步骤：
(0053) (1)编译烧写该程序到ATmega16，断开电源
(0054) (2)若使用ISP接口烧写程序，请断开ISP烧写器
(0055) （由于本示例程序使用的是ATmega16的SPI接口，刚好是ISP烧写器的烧写口）
(0056) (3)将LCD12864_ST7920插入主板的Lcd12864插槽
(0057) (4)使用连接线将LCD12864_ST7920的以下引针接口连接到MCU：
(0058) （由于SMK1632已经做好了大部分的硬件连接，您只需连接以下数据端口）
(0059) LCD12864_ST7920			ATmega16
(0060) 4.RS(CS)	--------	VCC
(0061) 5.R/W(SID)	--------	MOSI/PB5
(0062) 6.E(SCLK)	--------	SCK/PB7
(0063) 15.PSB		--------	GND
(0064) (5)上电，如果操作正确，这时您可以看到显示的内容了
(0065) 
(0066) ----------------------------------------------------------------------
(0067) 注意事项：
(0068) （1）若有加载库函数，请将光盘根目录下的“库函数”下的“ICC_H”文件夹拷到D盘 
(0069) （2）请详细阅读：光盘根目录下的“产品资料\开发板实验板\SMK系列\SMK1632\说明资料”
(0070) ----------------------------------------------------------------------
(0071) 10101010101010101010101010101010101010101010101010101010101010101010*/
(0072) 
(0073) #include <iom16v.h>
(0074) 
(0075) #include "D:\ICC_H\LCD12864_ST7920.H"
(0076) 
(0077) /*--------------------------------------------------------------------
(0078) 函数名称：
(0079) 函数功能：
(0080) 注意事项：
(0081) 提示说明：
(0082) 输    入：
(0083) 返    回：
(0084) --------------------------------------------------------------------*/
(0085) void main()
(0086) {             
(0087) 	SEI();
    03C1 9478      BSET	7
(0088) 	lcd_init();
    03C2 DFE9      RCALL	_lcd_init
(0089) 	lcd_puts(1,1,"  WaveShare.net");
    03C3 E68D      LDI	R24,0x6D
    03C4 E090      LDI	R25,0
    03C5 8399      STD	Y+1,R25
    03C6 8388      STD	Y+0,R24
    03C7 E021      LDI	R18,1
    03C8 E001      LDI	R16,1
    03C9 DF94      RCALL	_lcd_puts
(0090) 	lcd_puts(3,1,"    微雪电子");
    03CA E680      LDI	R24,0x60
    03CB E090      LDI	R25,0
    03CC 8399      STD	Y+1,R25
    03CD 8388      STD	Y+0,R24
    03CE E021      LDI	R18,1
    03CF E003      LDI	R16,3
    03D0 DF8D      RCALL	_lcd_puts
(0091) 	while(1);
FILE: <library>
    03D1 CFFF      RJMP	0x03D1
    03D2 9622      ADIW	R28,2
    03D3 9508      RET
push_arg4:
    03D4 933A      ST	R19,-Y
    03D5 932A      ST	R18,-Y
push_arg2:
    03D6 931A      ST	R17,-Y
    03D7 930A      ST	R16,-Y
    03D8 9508      RET
div32u:
    03D9 94E8      BCLR	6
    03DA C001      RJMP	0x03DC
mod32u:
    03DB 9468      BSET	6
    03DC D02F      RCALL	long_div_prolog
    03DD 24CC      CLR	R12
    03DE C008      RJMP	0x03E7
div32s:
    03DF 94E8      BCLR	6
    03E0 C001      RJMP	0x03E2
mod32s:
    03E1 9468      BSET	6
    03E2 D029      RCALL	long_div_prolog
    03E3 FD37      SBRC	R19,7
    03E4 D053      RCALL	neg_R16_R19
    03E5 FDB7      SBRC	R27,7
    03E6 D05A      RCALL	neg_R24_R27
    03E7 2477      CLR	R7
    03E8 2488      CLR	R8
    03E9 2499      CLR	R9
    03EA 24AA      CLR	R10
    03EB 24BB      CLR	R11
    03EC D041      RCALL	tst_R16_R19
    03ED F0C1      BEQ	0x0406
    03EE D044      RCALL	tst_R24_R27
    03EF F0B1      BEQ	0x0406
    03F0 E2E8      LDI	R30,0x28
    03F1 0F00      LSL	R16
    03F2 1F11      ROL	R17
    03F3 1F22      ROL	R18
    03F4 1F33      ROL	R19
    03F5 1C77      ROL	R7
    03F6 1C88      ROL	R8
    03F7 1C99      ROL	R9
    03F8 1CAA      ROL	R10
    03F9 1CBB      ROL	R11
    03FA 1688      CP	R8,R24
    03FB 0699      CPC	R9,R25
    03FC 06AA      CPC	R10,R26
    03FD 06BB      CPC	R11,R27
    03FE F028      BCS	0x0404
    03FF 1A88      SUB	R8,R24
    0400 0A99      SBC	R9,R25
    0401 0AAA      SBC	R10,R26
    0402 0ABB      SBC	R11,R27
    0403 9503      INC	R16
    0404 95EA      DEC	R30
    0405 F759      BNE	0x03F1
    0406 F426      BRTC	0x040B
    0407 2D08      MOV	R16,R8
    0408 2D19      MOV	R17,R9
    0409 2D2A      MOV	R18,R10
    040A 2D3B      MOV	R19,R11
    040B C013      RJMP	long_div_epilog
long_div_prolog:
    040C 927A      ST	R7,-Y
    040D 928A      ST	R8,-Y
    040E 929A      ST	R9,-Y
    040F 92AA      ST	R10,-Y
    0410 92BA      ST	R11,-Y
    0411 92CA      ST	R12,-Y
    0412 93EA      ST	R30,-Y
    0413 938A      ST	R24,-Y
    0414 939A      ST	R25,-Y
    0415 93AA      ST	R26,-Y
    0416 93BA      ST	R27,-Y
    0417 858B      LDD	R24,Y+11
    0418 859C      LDD	R25,Y+12
    0419 85AD      LDD	R26,Y+13
    041A 85BE      LDD	R27,Y+14
    041B 2EC3      MOV	R12,R19
    041C F00E      BRTS	0x041E
    041D 26CB      EOR	R12,R27
    041E 9508      RET
long_div_epilog:
    041F FCC7      SBRC	R12,7
    0420 D017      RCALL	neg_R16_R19
    0421 91B9      LD	R27,Y+
    0422 91A9      LD	R26,Y+
    0423 9199      LD	R25,Y+
    0424 9189      LD	R24,Y+
    0425 91E9      LD	R30,Y+
    0426 90C9      LD	R12,Y+
    0427 90B9      LD	R11,Y+
    0428 90A9      LD	R10,Y+
    0429 9099      LD	R9,Y+
    042A 9089      LD	R8,Y+
    042B 9079      LD	R7,Y+
    042C 9624      ADIW	R28,4
    042D 9508      RET
tst_R16_R19:
    042E 2FE0      MOV	R30,R16
    042F 2BE1      OR	R30,R17
    0430 2BE2      OR	R30,R18
    0431 2BE3      OR	R30,R19
    0432 9508      RET
tst_R24_R27:
    0433 2FE8      MOV	R30,R24
    0434 2BE9      OR	R30,R25
    0435 2BEA      OR	R30,R26
    0436 2BEB      OR	R30,R27
    0437 9508      RET
neg_R16_R19:
    0438 9500      COM	R16
    0439 9510      COM	R17
    043A 9520      COM	R18
    043B 9530      COM	R19
    043C 5F0F      SUBI	R16,0xFF
    043D 4F1F      SBCI	R17,0xFF
    043E 4F2F      SBCI	R18,0xFF
    043F 4F3F      SBCI	R19,0xFF
    0440 9508      RET
neg_R24_R27:
    0441 9580      COM	R24
    0442 9590      COM	R25
    0443 95A0      COM	R26
    0444 95B0      COM	R27
    0445 5F8F      SUBI	R24,0xFF
    0446 4F9F      SBCI	R25,0xFF
    0447 4FAF      SBCI	R26,0xFF
    0448 4FBF      SBCI	R27,0xFF
    0449 9508      RET
empy32u:
empy32s:
    044A 940E04A5  CALL	long_prolog
    044C 927F      PUSH	R7
    044D 940E04BE  CALL	tstzero1
    044F F139      BEQ	0x0477
    0450 2477      CLR	R7
    0451 940E04C4  CALL	tstzero2
    0453 F419      BNE	0x0457
    0454 018C      MOVW	R16,R24
    0455 019D      MOVW	R18,R26
    0456 C020      RJMP	0x0477
    0457 9F08      MUL	R16,R24
    0458 2CB0      MOV	R11,R0
    0459 2CA1      MOV	R10,R1
    045A 9F28      MUL	R18,R24
    045B 2C90      MOV	R9,R0
    045C 2C81      MOV	R8,R1
    045D 9F18      MUL	R17,R24
    045E 0CA0      ADD	R10,R0
    045F 1C91      ADC	R9,R1
    0460 1C87      ADC	R8,R7
    0461 9F09      MUL	R16,R25
    0462 0CA0      ADD	R10,R0
    0463 1C91      ADC	R9,R1
    0464 1C87      ADC	R8,R7
    0465 9F19      MUL	R17,R25
    0466 0C90      ADD	R9,R0
    0467 1C81      ADC	R8,R1
    0468 9F0A      MUL	R16,R26
    0469 0C90      ADD	R9,R0
    046A 1C81      ADC	R8,R1
    046B 9F38      MUL	R19,R24
    046C 0C80      ADD	R8,R0
    046D 9F29      MUL	R18,R25
    046E 0C80      ADD	R8,R0
    046F 9F1A      MUL	R17,R26
    0470 0C80      ADD	R8,R0
    0471 9F0B      MUL	R16,R27
    0472 0C80      ADD	R8,R0
    0473 2D0B      MOV	R16,R11
    0474 2D1A      MOV	R17,R10
    0475 2D29      MOV	R18,R9
    0476 2D38      MOV	R19,R8
    0477 907F      POP	R7
    0478 940C04B3  JMP	long_epilog
pop_gset2:
    047A E0E2      LDI	R30,2
    047B 940C0492  JMP	pop
pop_gset3:
    047D E0E4      LDI	R30,4
    047E 940C0492  JMP	pop
pop_gset4:
    0480 E0E8      LDI	R30,0x8
    0481 940C0492  JMP	pop
pop_gset5:
    0483 27EE      CLR	R30
    0484 940C0492  JMP	pop
push_gset5:
    0486 92FA      ST	R15,-Y
    0487 92EA      ST	R14,-Y
push_gset4:
    0488 92DA      ST	R13,-Y
    0489 92CA      ST	R12,-Y
push_gset3:
    048A 92BA      ST	R11,-Y
    048B 92AA      ST	R10,-Y
push_gset2:
    048C 937A      ST	R23,-Y
    048D 936A      ST	R22,-Y
push_gset1:
    048E 935A      ST	R21,-Y
    048F 934A      ST	R20,-Y
    0490 9508      RET
pop_gset1:
    0491 E0E1      LDI	R30,1
pop:
    0492 9149      LD	R20,Y+
    0493 9159      LD	R21,Y+
    0494 FDE0      SBRC	R30,0
    0495 9508      RET
    0496 9169      LD	R22,Y+
    0497 9179      LD	R23,Y+
    0498 FDE1      SBRC	R30,1
    0499 9508      RET
    049A 90A9      LD	R10,Y+
    049B 90B9      LD	R11,Y+
    049C FDE2      SBRC	R30,2
    049D 9508      RET
    049E 90C9      LD	R12,Y+
    049F 90D9      LD	R13,Y+
    04A0 FDE3      SBRC	R30,3
    04A1 9508      RET
    04A2 90E9      LD	R14,Y+
    04A3 90F9      LD	R15,Y+
    04A4 9508      RET
long_prolog:
    04A5 928A      ST	R8,-Y
    04A6 929A      ST	R9,-Y
    04A7 92AA      ST	R10,-Y
    04A8 92BA      ST	R11,-Y
    04A9 93EA      ST	R30,-Y
    04AA 938A      ST	R24,-Y
    04AB 939A      ST	R25,-Y
    04AC 93AA      ST	R26,-Y
    04AD 93BA      ST	R27,-Y
    04AE 8589      LDD	R24,Y+9
    04AF 859A      LDD	R25,Y+10
    04B0 85AB      LDD	R26,Y+11
    04B1 85BC      LDD	R27,Y+12
    04B2 9508      RET
long_epilog:
    04B3 91B9      LD	R27,Y+
    04B4 91A9      LD	R26,Y+
    04B5 9199      LD	R25,Y+
    04B6 9189      LD	R24,Y+
    04B7 91E9      LD	R30,Y+
    04B8 90B9      LD	R11,Y+
    04B9 90A9      LD	R10,Y+
    04BA 9099      LD	R9,Y+
    04BB 9089      LD	R8,Y+
    04BC 9624      ADIW	R28,4
    04BD 9508      RET
tstzero1:
    04BE 27EE      CLR	R30
    04BF 2BE0      OR	R30,R16
    04C0 2BE1      OR	R30,R17
    04C1 2BE2      OR	R30,R18
    04C2 2BE3      OR	R30,R19
    04C3 9508      RET
tstzero2:
    04C4 27EE      CLR	R30
    04C5 2BE8      OR	R30,R24
    04C6 2BE9      OR	R30,R25
    04C7 2BEA      OR	R30,R26
    04C8 2BEB      OR	R30,R27
    04C9 9508      RET
